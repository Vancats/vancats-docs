---
date created: 2022-05-16 16:27
date updated: 2022-05-17 19:03
---

### 7. 实现双向数据绑定

```javascript
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
    configurable: true,
    enumerable: true,
    get() {console.log('获得数据了')},
    set(newVal) {
        console.log('数据更新了')
        input.value = newVal
        span.innerHtml = newVal
    }
})

// 输入监听
input.addEventListener('keyup', function(e) {
    obj.text = e.target.value
})
```

### 8. 懒加载

```javascript
let img = document.querySelectorAll('img')
// 可视区高度
let clientHeight = window.innerHeight || document.documentElement.clientHeight ||document.body.clientHeight
function lazyLoad(){
    let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
    for(let i = 0; i < imgs.length; i++){
		// 图片在可视区冒出的高度
        let x = clientHeight + scrollTop - imgs[i].offsetTop
        // 图片在可视区内
        if(x > 0 && x < clientHeight + imgs[i].height) {
            imgs[i].src = imgs[i].getAttribute('data')
        }
    }
}
addEventListener('scroll', lazyLoad) // setInterval(lazyLoad, 1000)
```

### 9. 实现简单路由

```javascript
// hash 路由
class Route{
    construtor(){
        // 路由储存对象
        this.routes = {}
        // 当前 hash
        this.currentHash = ''
        // 绑定this，避免指向改变
        this.freshRoute = this.freshRoute.bind(this)
        // 监听
        window.addEventListener('load', this.freshRoute, false)
        window.addEventListener('hashChange', this.freshRoute, false)
    }
    // 存储
    storeRoute(path, cb) {
        this.routes[path] = cb || function(){}
    }
    // 更新
    freshRoute() {
        this.currentHash = location.hash.slice(1) || '/'
        this.route[this.currentHash]()
    }
}
```

### 10. 实现一个基本的Event Bus

```javascript
// 组件通信，一个触发与监听的过程
class EventEmitter {
  constructor () {
    // 存储事件
    this.events = this.events || new Map()
  }
  // 监听事件
  addListener (type, fn) {
    if (!this.events.get(type)) {
      this.events.set(type, fn)
    }
  }
  // 触发事件
  emit (type) {
    let handle = this.events.get(type)
    handle.apply(this, [...arguments].slice(1))
  }
}
// 测试
let emitter = new EventEmitter()
// 监听事件
emitter.addListener('ages', age => {
  console.log(age)
})
// 触发事件
emitter.emit('ages', 18)  // 18
```

### 14. 单例模式

```javascript
var SingleTon = function(name) {this.name = name}
SingleTon.prototype.getName = function(){return this.name}
SingleTon.prototype.getInstance = function(name){
    if(!this.instance) this.instance = new SingleTon(name)
    return this.instance
}
var a = SingleTon,getInstance('111')
var b = SingleTon,getInstance('222')
alert(a === b) // true
```

### 15. 发布者订阅模式

```javascript
class EventEmitter {
    constructor(){ this.subs = {} }
    // 注册事件
    on(event, cb) {
        (this.subs[event] || (this.subs[event] = [])).push(cb)
    }
    // 触发事件
    trigger(event, ...args) {
        this.subs[event] && 
            this.subs[event].forEach(cb => {
            cb(...args)
        })
    }
    // 只触发一次的事件
    once(event, onceCb) {
        const cb = (...args) => {
            onceCb(...args)
            this.off(event, onceCb)
        }
        this.on(event, cb)
    }
    //注销事件
    off(event, offCb) {
        if(!this.subs[event]){
            let index = this.subs[event].findIndex(cb => cb === offCb)
            this.subs[event].splice(index, 1)
            if(!this.subs[event].length) delete this.subs[event]
        }
    }
}
```

### 16. 实现 Object.assign

```javascript
const isComplectDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && obj !== null

const selfAssign = function(target, ...source) {
    if(target ==null) throw TypeError('Cannot convert undefined or null to object')
    return source.reduce((acc, cur) => {
        isComplexDataType(acc) || (acc = new Object(acc))
        if(cur == null) return acc
        [...Object.keys(cur), ...Object.getOwnPropertySymbols(cur)]
            .forEach(key => {acc[key] = cur[key]})
        return acc
    }, target)
}
```

### 17. 实现 Class 语法

```javascript
function inherit(subType, superType) {
    // 寄生组合式继承，完成实例和实例之间的继承
    // subType.prototype = 空对象   空对象.prototype = superType.prototyoe
    subType.prototype = Object.create(superType.prototype, {
        constructor: {
            enumerable: false,
            configurable: true,
            writable: true,
            value: subType
        }
    })
    // 从父类中继承静态方法和属性
    Object.setPrototypeOf(subType, superType)
}
```

### 18. 实现 filter

```javascript
function selfFilter(fn, context) {
    if(typeof fn !== 'function') { throw new TypeError(`${fn} is not a function`)}
    let arr = this, temp = []
    for(let i = 0; i < arr.length; i++) {
        let result = fn.call(context, arr[i], i, arr)
        if(result) temp.push(arr[i])
    }
    return temp
}
Array.prototype.selfFilter = selfFilter
```

### 19. 实现 map

```javascript
const selfMap = function(fn, context) {
    let arr = Array.prototype.slice.call(this)
    let mappedArr = []
    for(let i = 0; i < arr.length; i++) {
        // 判断稀疏数组
        if(!arr.hasOwnProperty(i)) continue
        mappedArr[i] = fn.call(context, arr[i], i, this)
    }
    return mappedArr
}
const selfMap = function(fn, context) {
    let arr = Array.prototype.slice.call(this)
    return arr.reduce((pre, cur, index) => {
        return [...pre, fn.call(context, cur, index, this)]
    }, [])
}
Array.prototype.selfMap = selfMap
```

### 21. 实现 Reduce

```javascript
Array.prototype.selfReduce = function(cb, initialValue) {
    const array = this
    let acc = initialValue || array[0]
    const startIndex = initialValue ? 0: 1
    for(let i = startIndex; i < array.length; i++) {
        const cur = array[i]
        // 上一次的返回值 prev 当前值 cur 索引 index 数组对象 array
        acc = cb(acc, cur, i, array)
    }
    return acc
}
```

### 23. setTimeout 输出

- 改变循环体

  - 将此部分转移到外部，根据 按值传递 特性改造

- 自执行函数

  ```javascript
  (function(j) {
          setTimeout(function() {
              console.log(new Date, j);
          }, 1000 * j);  // 这里修改 0~4 的定时器时间
      })(i);
  ```

- Promise

  ```javascript
  const tasks = []; // 这里存放异步操作的 Promise
  const output = (i) => new Promise((resolve) => {
      setTimeout(() => {
          console.log(new Date, i);
          resolve(); // 必须要加
      }, 1000 * i);
  });
  // 生成全部的异步操作
  for (var i = 0; i < 5; i++) {
      tasks.push(output(i));
  }
  // 异步操作完成之后，输出最后的 i
  Promise.all(tasks).then(() => {
      setTimeout(() => {
          console.log(new Date, i);
      }, 1000);
  });
  ```
