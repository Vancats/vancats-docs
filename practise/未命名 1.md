---
date created: 2022-04-27 10:04
date updated: 2022-04-27 10:07
---

当我们调用 `del` 或者 `set` 方法的是，会通知更新 `ob.dep.notify()`

接下来的几个步骤就是更新内容，关键点在于

```js
this.deps = []
this.newDeps = []
this.depIds = new Set()
this.newDepIds = new Set()
```

这是 `Watcher` 中存的新旧 `deps`，在我们更新内容的时候，做的操作都是在新 `deps` 上操作

```js
addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this)
    }
  }
}
```

所以，在我们的 `updateComponent` 更新完成之后，我们是不是会根据以上情况获得一份新的 deps

```js
get() {
  pushTarget(this)
  let value
  const vm = this.vm
  try {

    value = this.getter.call(vm, vm)

  } catch (e) {

    if (this.user) {

      handleError(e, vm, `getter for watcher "${this.expression}"`)

    } else {

      throw e

    }

  } finally {

    // "touch" every property so they are all tracked as

    // dependencies for deep watching

    if (this.deep) {

      traverse(value)

    }

    popTarget()

    this.cleanupDeps()

  }

  return value

}
```