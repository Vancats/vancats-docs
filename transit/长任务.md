---
date created: 2022-04-24 18:03
date updated: 2022-04-24 18:08
---

#### 长任务

概念：运行时间超过 50ms 的任务

原因：长任务下，用户会感知到渲染和交互上的卡顿

##### 时间切片方法

处理方法：首先将该任务改成一个 `generate` 函数，使其可异步，然后通过宏任务方法（一般使用 `setTimeout`）推入宏任务队列，使其延迟执行，从而不影响主执行栈。

**例子**

```js
function fnc() {
  let i = 0
  const start = performance.now()
  while (performance.now() - start <= 5000) i++
  return i
}
```

这是一个很明显的长任务，执行时间为 5000 ms，如果不处理的话，在执行这段代码的时候，会很明显的感知到卡顿现象。

```js
function* fn() {
  let i = 0
  const start = performance.now()
  while (performance.now() - start <= 5000)
    yield i++
  return i
}
```

首先转换成一个 `generate` 函数以便后续处理。

```js
function timeSlice(fn, cb = setTimeout) {
  // 当不是一个 generate 函数时，正常返回
  if (fn.constructor.name !== 'GeneratorFunction') return fn()
  // 返回一个 async 函数
  return async function (...args) {
    // 获取原函数
    const _fn = fn(...args)
    let data
    do {
      // 执行其 next 方法
      data = _fn.next(await data?.value)
      // 每执行一步就休眠，注册一个宏任务 setTimeout 来叫醒他
      await new Promise(resolve => cb(resolve))
    } while (!data.done)
    return data.value
  }
}

setTimeout(async () => {
  // 获取到封装后的函数
  const fnc = timeSlice(fn)
  const start = performance.now()
  console.log('开始')
  const num = await fnc()
  console.log('结束', `${(performance.now() - start) / 1000}s`)
  console.log(num)
}, 1000)
```

以上方法可以比较方便的进行时间切片，但是总体效率没有那么高。现在我们是每次取 `performance.now` 时都会进行一次以上操作，时间切分有点过于小了，可以进行一次优化。

```js
// 加入自定义切片时间
function timeSlice(fn, time = 25, cb = setTimeout) {
  if (fn.constructor.name !== 'GeneratorFunction') return fn()
  
  return function (...args) {
    const _fn = fn(...args)
    let data
    return new Promise(async function go(resolve, reject) {
      try {
        const start = performance.now()
        do
          data = _fn.next(await data?.value)
        // 增加时间条件，在超过指定切片时间之后跳出
        while (!data.done && performance.now() - start < time)
  
        if (data.done) return resolve(data.value)
        // 从循环内移除，方便控制时间
        cb(() => go(resolve, reject))
      }
      catch (e) {
        reject(e)
      }
    })
  }
}
```

在正常的开发中，主要的难点在于我们对 `yield` 参数的定义点，以及切片时间的控制。

###### web worker

web worker 允许我们创建独立于主线程的其他线程，很适合我们处理长任务，缺点在于 DOM 操作不方便。
